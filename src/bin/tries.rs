//! This example shows powerful PIO module in the RP2040 chip to communicate with WS2812 LED modules.
//! See (https://www.sparkfun.com/categories/tags/ws2812)

#![no_std]
#![no_main]

use core::fmt::Write;
use defmt::*;
use embedded_hal_bus::spi::ExclusiveDevice;
use embassy_executor::Spawner;
use embassy_rp::bind_interrupts;
use embassy_rp::gpio::{Output, Level};
use embassy_rp::peripherals::{DMA_CH0, PIO0, PIN_25, USB};
use embassy_rp::pio::{InterruptHandler as PioInt, Pio};
use embassy_rp::pio_programs::ws2812::{PioWs2812, PioWs2812Program};
use embassy_rp::spi::{self, Spi};
use embassy_rp::usb::{Driver, InterruptHandler as UsbInt};
use embassy_time::{Duration, Ticker, Timer, Delay};
use smart_leds::RGB8;
use {defmt_rtt as _, panic_probe as _};

pub mod pcd8544;
use pcd8544::Pcd8544;

bind_interrupts!(struct Irqs {
    PIO0_IRQ_0 => PioInt<PIO0>;
    USBCTRL_IRQ => UsbInt<USB>;
});

#[embassy_executor::task]
async fn logger_task(driver: Driver<'static, USB>) {
    embassy_usb_logger::run!(1024, log::LevelFilter::Info, driver);
}

/// Input a value 0 to 255 to get a color value
/// The colours are a transition r - g - b - back to r.
fn wheel(mut wheel_pos: u8) -> RGB8 {
    wheel_pos = 255 - wheel_pos;
    if wheel_pos < 85 {
        return (255 - wheel_pos * 3, 0, wheel_pos * 3).into();
    }
    if wheel_pos < 170 {
        wheel_pos -= 85;
        return (0, wheel_pos * 3, 255 - wheel_pos * 3).into();
    }
    wheel_pos -= 170;
    (wheel_pos * 3, 255 - wheel_pos * 3, 0).into()
}

#[embassy_executor::main]
async fn main(spawner: Spawner) {
    info!("Start");
    let p = embassy_rp::init(Default::default());
    let mut delayer = Delay{};

    let usb_driver = Driver::new(p.USB, Irqs);
    let _ = spawner.spawn(logger_task(usb_driver));

    let _ = spawner.spawn(rainbow(p.PIN_25, p.DMA_CH0, p.PIO0));

    let lcd_dc    = Output::new(p.PIN_20, Level::Low);
    let lcd_ce    = Output::new(p.PIN_21, Level::High);
    let lcd_rst   = Output::new(p.PIN_26, Level::Low);
    let mut lcd_light = Output::new(p.PIN_27, Level::High);
    // lcd_light.set_high();
    lcd_light.set_low();
    let mut cfg = spi::Config::default();
    cfg.frequency = 2_000_000;
    let spi_bus = Spi::new_blocking_txonly(p.SPI0, p.PIN_22, p.PIN_23, cfg);
    // TODO: should not use new_no_delay but regular new
    let spi_dev = ExclusiveDevice::new_no_delay(spi_bus, lcd_ce);
    // use embassy_embedded_hal::shared_bus::blocking::spi::SpiDevice;
    // let spi_dev = SpiDevice::new(spi_bus, lcd_ce);
    let mut lcd = Pcd8544::new(spi_dev, lcd_dc, lcd_rst, &mut delayer).expect("cannot fail");
    // test pattern (50% on)
    let ar: [u8; 42*6*2] = core::array::from_fn(|i| if i%2 == 0 { 0x55u8 } else { 0xAAu8 });
    let _ = lcd.data(&ar);

    let _ = lcd.clear();
    let _ = lcd.position(0, 0);
    let _ = lcd.data(&[0xE0, 0x38, 0xE4, 0x22, 0xA2, 0xE1, 0xE1, 0x61, 0xE1, 0x21, 0xA2, 0xE2, 0xE4, 0x38, 0xE0, 0x00]);
    let _ = lcd.position(0, 1);
    let _ = lcd.data(&[0x03, 0x0C, 0x10, 0x21, 0x21, 0x41, 0x48, 0x48, 0x48, 0x49, 0x25, 0x21, 0x10, 0x0C, 0x03, 0x00]);

    // based on Vault Boy cross-stitch pattern by IFeel_Attacked (https://redd.it/rnt3ou)
    // copied and cropped manually, converted with https://javl.github.io/image2cpp/
    let _ = lcd.position(0, 0);
    let _ = lcd.data(&[
        0x3e, 0x41, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0c, 0x0b, 0x10, 0x10, 0x1f, 0x21, 0x20,
        0x40, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x80, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0x10, 0x08, 0x88, 0x48, 0x4f, 0x40, 0x40,
        0x80, 0x00, 0x00, 0x3e, 0x63, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x04, 0x02, 0x02, 0x02, 0x02,
        0x01, 0x01, 0x01, 0x01, 0x01, 0xf9, 0x0d, 0xf6, 0x0b, 0xc4, 0x3a, 0x25, 0x25, 0x25, 0x45, 0x45,
        0x42, 0x46, 0x78, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x04, 0x08, 0x8e, 0x89, 0x50, 0x30, 0x1c, 0x12, 0x09, 0x00,
        0x00, 0x00, 0x81, 0x81, 0x81, 0x41, 0x42, 0x82, 0x84, 0x0b, 0x1c, 0x34, 0xc4, 0x04, 0x06, 0x02,
        0x02, 0x02, 0x02, 0x02, 0x02, 0x06, 0x04, 0x04, 0x0c, 0x0b, 0x0c, 0x1b, 0x20, 0x40, 0x9d, 0x23,
        0x22, 0x42, 0xc4, 0x44, 0x44, 0x42, 0x42, 0x25, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8e, 0x71, 0x91, 0x40, 0xa0, 0x00, 0x00,
        0x00, 0x00, 0x80, 0x00, 0x02, 0x03, 0x02, 0x02, 0x02, 0x0a, 0xf2, 0x62, 0x02, 0x03, 0x02, 0x00,
        0x01, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x30, 0x4f, 0x80, 0x80, 0x40, 0x23, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x83, 0x05, 0x62,
        0x95, 0x8a, 0x80, 0x80, 0x80, 0x80, 0x19, 0x13, 0x33, 0x01, 0x00, 0x00, 0x02, 0x01, 0x00, 0x80,
        0x57, 0x57, 0x20, 0x58, 0xc7, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x01, 0x02, 0x04, 0x04, 0x18, 0x20, 0x20, 0x20, 0x20, 0x41, 0x82, 0x82, 0x42, 0x31, 0x11,
        0x21, 0x22, 0x11, 0x08, 0x04, 0x04, 0x14, 0x18, 0x0c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    ]);

    let mut counter = 0;
    loop {
        counter += 1;
        log::info!("Tick {}", counter);

        // lcd.set_light(counter % 2 == 0);
        Timer::after_secs(1).await;

    }
}

#[embassy_executor::task]
async fn rainbow(pin: PIN_25, dma: DMA_CH0, pio: PIO0) {
    // This is the number of leds in the string. Helpfully, the sparkfun thing plus and adafruit
    // feather boards for the 2040 both have one built in.
    const NUM_LEDS: usize = 1;
    let mut data = [RGB8::default(); NUM_LEDS];

    let Pio { mut common, sm0, .. } = Pio::new(pio, Irqs);

    // Common neopixel pins:
    // Thing plus: 8
    // Adafruit Feather: 16;  Adafruit Feather+RFM95: 4
    let program = PioWs2812Program::new(&mut common);
    let mut ws2812 = PioWs2812::new(&mut common, sm0, dma, pin, &program);

    // Loop forever making RGB values and pushing them out to the WS2812.
    let mut ticker = Ticker::every(Duration::from_millis(10));
    loop {
        for j in 0..(256 * 5) {
            debug!("New Colors:");
            for i in 0..NUM_LEDS {
                data[i] = wheel((((i * 256) as u16 / NUM_LEDS as u16 + j as u16) & 255) as u8);
                debug!("R: {} G: {} B: {}", data[i].r, data[i].g, data[i].b);
            }
            data[0] = (0,0,0).into(); // temporariy turn off the horrible light...
            ws2812.write(&data).await;

            ticker.next().await;
        }
    }
}

